#!/bin/bash -eu


ORIG_PROG_BIN="$0"


set_globals()
{
    PROG_BIN="$(abspath "$ORIG_PROG_BIN")"
    PROG_DIR="$(dirname "$PROG_BIN")"
    PROG_NAME="$(basename "$PROG_BIN")"
    USER_CONF="$HOME/.$PROG_NAME"
    CONFIG_DIR="$(abspath "$PROG_DIR/../etc")"
    CONCERN=""
    JOB_ID="$$"
    DO_PUBLISH="false"
    DOCKER_TAG_ENFORCE="false"
    IMAGE_NAMESPACE="c12e"
    WORKSPACE="$(pwd)"
    DEBUG_LEVEL="0"  # IDEA: actually use DEBUG_LEVEL
    USAGE="$PROG_NAME -n JOB_NAME -i JOB_IMAGE_BASE [options]...
    COMMAND ARGS...

Run continuous integration jobs.

You can set these options in $USER_CONF using
the argument names documented here.

Required:

    -n JOB_NAME
        insights, dss, retailsearch, ...
        (used for Docker image/container names)

Options:

    -c CONCERN
        a tag for the job and Docker image (dev, qa, ...)

    -p
        Build and publish Docker images (just run CI job)

    -I JOB_ID
        unique identification for each job run (like CI build number,
        default is the PID)

    -w WORKSPACE
        when building, the volume to mount as a the build source code root
        (default: current working directory)

    -N IMAGE_NAMESPACE
        the Docker namespace to use when building and publishing the artifact
        (default: $IMAGE_NAMESPACE)

    -t
        ignore the existing tag in docker and republish
        (default: false)

    -h
        print this usage information"
}


main()
{
    set_globals
    source_conf
    while getopts n:c:I:w:N:tpvh f
    do
        case $f in
            n) JOB_NAME="$(canonical "${OPTARG}")";;
            c) CONCERN="$(canonical "${OPTARG}")";;
            I) JOB_ID="$(canonical "${OPTARG}")";;
            w) WORKSPACE="$(abspath "$OPTARG")";;
            N) IMAGE_NAMESPACE="$(canonical "$OPTARG")";;
            t) DOCKER_TAG_ENFORCE="true";;
            p) DO_PUBLISH="true";;
            v) DEBUG_LEVEL="$((DEBUG_LEVEL + 1))";;
            h) echo "$USAGE"; exit 0;;
            \?) die "missing required argument to switch";;
        esac
    done
    shift $((OPTIND - 1))

    validate_inputs

    local short_tag
    short_tag="$(version_from_git "$WORKSPACE")"

    local full_tag
    full_tag="$IMAGE_NAMESPACE/$JOB_NAME:$short_tag"

    local container_name_prefix
    container_name_prefix="${JOB_NAME}${JOB_ID}"

    local tag_url_base
    tag_url_base="$(make_tag_url_base "$IMAGE_NAMESPACE" "$JOB_NAME")"

    local concern
    concern="$(make_concern "$CONCERN")"

    if no_docker_publish "$WORKSPACE" "$DO_PUBLISH"
    then
        header "running CI job (no Docker image)"
        run_ci_job "$container_name_prefix" "$WORKSPACE" "$CONFIG_DIR" "$@"
    else
        if [ ! $DOCKER_TAG_ENFORCE = "true" ] \
            || not_docker_published "$tag_url_base" "$short_tag"
        then
            header "running CI job"
            run_ci_job "$container_name_prefix" "$WORKSPACE" "$CONFIG_DIR" "$@"
            header "building Docker image"
            image_hash=$(docker_build "$full_tag" "$WORKSPACE")
            header "publishing Docker image"
            docker_publish \
                "$full_tag" "$short_tag" "$image_hash" \
                "$concern" "$IMAGE_NAMESPACE/$JOB_NAME"
            write_report "$full_tag" "$JOB_NAME" "$WORKSPACE"
        else
            header "already published to Docker: $short_tag"
        fi
    fi

    header "SUCCESS: finished everything"

}


source_conf()
{
    if [ -r "$USER_CONF" ]
    then . "$USER_CONF"
    fi
}


validate_inputs()
{
    set +u
    if [ -z "$JOB_NAME" ]
    then die "MISSING: required job name (-n switch)"
    fi
    set -u
}


version_from_git()
{
    local workspace="$1"
    git -C "$workspace" describe --long --always --dirty --match='v*.*' \
        | sed 's/v//; s/-/./'
}


make_tag_url_base()
{
    local namespace="$1"
    local job="$2"
    echo "https://registry.hub.docker.com/v1/repositories/$namespace/$job/tags"
}


make_concern()
{
    local concern="$1"
    if [ -n "$concern" ]
    then echo "$concern"
    else whoami
    fi
}


no_docker_publish()
{
    local workspace="$1"
    local do_publish="$2"
    ! test -r "$workspace/Dockerfile" -a "$do_publish" = true
}


not_docker_published()
{
    return 0
    local tag_url_base="$1"
    local version_tag="$2"
    url="$tag_url_base/$version_tag"
    local status
    status="$(
        curl --basic --netrc --silent --include "$url" \
            | head -n 1 \
            | awk '{print $2}')"
    if [ "$status" -eq 200 ]; then
      return 1
    elif [ "$status" -eq 404 ]; then
      return 0
    else
       die "$url returned error: $status"
    fi
}


run_ci_job()
{
    local container_name_prefix="$1"
    local workspace_dir="$2"
    local config_dir="$3"
    shift 3
    local compose_conf_common="$config_dir/c12e-ci.compose.common.yml"
    local compose_conf_specific
    compose_conf_specific="$config_dir/$(pick_compose_specific)"
    local compose_conf_build="$workspace_dir/c12e-ci.yml"
    compose_conf_build="$(pick_compose_build "$workspace_dir" "$config_dir")"

    set_cleanup \
        "$workspace_dir" \
        "$container_name_prefix" \
        "$compose_conf_common" \
        "$compose_conf_specific" \
        "$compose_conf_build"

    create_nix_data
    create_dev_home

    local C12ECI_CONTAINER; C12ECI_CONTAINER="$(container_id)"
    export C12ECI_CONTAINER
    local C12ECI_WORK_DIR
    export C12ECI_WORK_DIR="$workspace_dir"

    docker-compose \
        --project-name "$container_name_prefix" \
        --file "$compose_conf_common" \
        --file "$compose_conf_specific" \
        --file "$compose_conf_build" \
        run --rm builder \
        "$@"

}


docker_build()
{
    local tag="$1"
    local workspace="$2"
    docker build \
            --pull=true \
            --force-rm=false \
            --tag "$tag" \
            "$workspace" \
        | tee /dev/stderr \
        | tail -1 \
        | awk '{ print $3 }'
}


docker_publish()
{
    local full_tag="$1"
    local short_tag="$2"
    local image_hash="$3"
    local concern="$4"
    local image_name="$5"
    docker push "$full_tag"
    header "tagging Docker images"
    tag "$image_name" "$short_tag" "$concern"
    docker rmi -f "$image_hash"
}


write_report()
{
    local docker_image="$1"
    local job_name="$2"
    local workspace="$3"
    local target_dir="$workspace/cruise-output"
    local gitHash; gitHash="$(git rev-parse HEAD)"
    local timestamp; timestamp="$(date -u +%FT%TZ)"
    if on_ci_server
    then
        mkdir -p "$target_dir"
        cat << EOF > "$target_dir/buildReport.json"
{
   "name": "$job_name",
   "docker_tag": "$docker_image",
   "git_hash": "$gitHash",
   "timestamp": "$timestamp"
}
EOF
    fi
}


pick_compose_specific()
{
    if on_ci_server
    then echo "c12e-ci.compose.gocd.yml"
    else echo "c12e-ci.compose.dev.yml"
    fi
}


pick_compose_build()
{
    local workspace="$1"
    local config_dir="$2"
    local workspace_config="$workspace/c12e-ci.yml"
    if [ -r "$workspace_config" ]
    then echo "$workspace_config"
    else echo "$config_dir/c12e-ci.compose.noop.yml"
    fi
}


create_nix_data()
{
    local name="nix-data"
    if ! container_created "$name"
    then
        docker run \
            --name "$name" \
            --entrypoint true \
            c12e/c12e-nix-builder:0.0.0-g91b10e7
    fi
}


create_dev_home()
{
    local name="dev-home"
    if ! (on_ci_server || container_created "$name")
    then
        mkdir -p "$HOME/.sbt" "$HOME/.ivy2" "$HOME/.docker"
        docker run \
            --name "$name" \
            --entrypoint /bin/cp \
            --volume "${HOME}:/mnt" \
            --volume /root \
            busybox \
            -r /mnt/.sbt /mnt/.ivy2 /mnt/.docker /root
    fi
}


container_id()
{
    if [ -r /proc/self/cgroup ]
    then basename "$(egrep '.*\bcpu\b.*:/docker/' /proc/self/cgroup)"
    fi
}


tag()
{
    local image_name="$1"
    local original="$2"
    local concern="$3"
    for new in \
        "${original}-${concern}" \
        "${concern}-latest" \
        "latest-${concern}"
    do
        echo "tagging: $new -> $original"
	    docker tag "$image_name:$original" "$image_name:$new"
	    docker push "$image_name:$new"
    done
}


on_ci_server()
{
    test "$(whoami)" = "root"
}


container_created()
{
    local name="$1"
    docker ps --all --format "{{.Names}}" | grep "^${name}$"
}


set_cleanup()
{
    local workspace_dir="$1"
    local container_name_prefix="$2"
    local compose_conf_common="$3"
    local compose_conf_specific="$4"
    local compose_conf_build="$5"
    # DESIGN: http://mywiki.wooledge.org/SignalTrap
    local cmd="cleanup \
            $workspace_dir \
            $container_name_prefix \
            $compose_conf_common \
            $compose_conf_specific \
            $compose_conf_build"
    trap "$cmd" EXIT
    trap "$cmd; trap - INT; kill -INT $$; sleep 1" INT TERM
}


cleanup()
{
    local workspace_dir="$1"
    local container_name_prefix="$2"
    local compose_conf_common="$3"
    local compose_conf_specific="$4"
    local compose_conf_build="$5"

    header "cleaning up Docker processes"

    local C12ECI_CONTAINER; C12ECI_CONTAINER="$(container_id)"
    export C12ECI_CONTAINER
    local C12ECI_WORK_DIR
    export C12ECI_WORK_DIR="$workspace_dir"

    docker-compose \
        --project-name "$container_name_prefix" \
        --file "$compose_conf_common" \
        --file "$compose_conf_specific" \
        --file "$compose_conf_build" \
        stop

    docker-compose \
        --project-name "$container_name_prefix" \
        --file "$compose_conf_common" \
        --file "$compose_conf_specific" \
        --file "$compose_conf_build" \
        rm --force -v

    header "cleaning up dangling Docker images"

    for image in $(docker images --filter "dangling=true" --quiet --no-trunc)
    do docker rmi "$image" || true
    done

    header "cleaning up workspace"

    local ownership
    ownership="$(id -u):$(id -g)"

    docker run \
        --name "${container_name_prefix}_clean_workspace" \
        --rm \
        --volume "${workspace_dir}:/workspace" \
        busybox:latest \
        chown -R "$ownership" /workspace || true

    header "finished cleanup"
}


die()
{
    local msg="$1"
    {
        echo "$USAGE"
        echo
        echo "ERROR: $msg"
    } > /dev/stderr
    exit 1
}


canonical()
{
    echo "$@" | sed 's/[^a-zA-Z0-9-]//g' | tr '[:upper:]' '[:lower:]'
}


header()
{
    echo
    echo "****"
    echo "**** $*"
    echo "****"
    echo
}


abspath()
{
    local target="$1"
    local old_pwd
    old_pwd="$(pwd)"
    cd "$(dirname "$target")"
    while [ -L "$target" ]; do
        target="$(readlink "$target")"
        cd "$(dirname "$target")"
    done
    echo "$(pwd -P)/$(basename "$target")"
    cd "$old_pwd"
}


main "$@"
