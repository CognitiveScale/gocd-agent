#!/bin/bash -eu

ORIG_PROG_BIN="$0"
DOCKER_AUTH_URL="https://auth.docker.io/token?service=registry.docker.io&scope=repository"
DOCKER_REGISTRY_URL="https://registry-1.docker.io/v2"
NIX_BUILDER_IMAGE="c12e/c12e-nix-builder:0.0.0-g91b10e7"


set_globals()
{
    PROG_BIN="$(abspath "$ORIG_PROG_BIN")"
    PROG_DIR="$(dirname "$PROG_BIN")"
    PROG_NAME="$(basename "$PROG_BIN")"
    USER_CONF="$HOME/.$PROG_NAME"
    CONFIG_DIR="$(abspath "$PROG_DIR/../etc")"
    CONCERN=""
    JOB_ID="$$"
    DOCKER_PUBLISH="false"
    DOCKER_PUBLISH_FORCE="false"
    IMAGE_NAMESPACE="c12e"
    WORKSPACE="$(pwd)"
    DEBUG_LEVEL="0"  # IDEA: actually use DEBUG_LEVEL
    USAGE="$PROG_NAME -n JOB_NAME [options...] [COMMAND ARGS...]

Run continuous integration job.

A c12e-ci.yml file is normally in the workspace to define how to run the job
with Docker-compose.  Otherwise, the command is a no-op.  You can override the
command optionally from the command-line.

You can set these options in $USER_CONF using the argument names
documented here.

Required:

    -n JOB_NAME
        insights, dss, retailsearch, ...
        (used for Docker image/container names)

Options:

    -c CONCERN
        a tag for the job and Docker image (dev, qa, ...)

    -p
        Build and publish Docker images (just run CI job)

    -I JOB_ID
        unique identification for each job run (like CI build number,
        default is the PID)

    -w WORKSPACE
        when building, the volume to mount as a the build source code root
        (default: current working directory)

    -N IMAGE_NAMESPACE
        the Docker namespace to use when building and publishing the artifact
        (default: $IMAGE_NAMESPACE)

    -F
        ignore the existing tag in docker and republish
        (default: $DOCKER_PUBLISH_FORCE)

    -h
        print this usage information"
}


main()
{
    set_globals
    source_conf
    while getopts n:c:I:w:N:pFvh f
    do
        case $f in
            n) JOB_NAME="$(canonical "${OPTARG}")";;
            c) CONCERN="$(canonical "${OPTARG}")";;
            I) JOB_ID="$(canonical "${OPTARG}")";;
            w) WORKSPACE="$(abspath "$OPTARG")";;
            N) IMAGE_NAMESPACE="$(canonical "$OPTARG")";;
            p) DOCKER_PUBLISH="true";;
            F) DOCKER_PUBLISH_FORCE="true";;
            v) DEBUG_LEVEL="$((DEBUG_LEVEL + 1))";;
            h) echo "$USAGE"; exit 0;;
            \?) die "missing required argument to switch";;
        esac
    done
    shift $((OPTIND - 1))

    validate_inputs

    local concern
    concern="$(make_concern "$CONCERN")"

    local short_tag
    short_tag="$(make_short_tag "$WORKSPACE" "$concern")"

    local namespace="$IMAGE_NAMESPACE"
    local repo="$JOB_NAME"
    local config_dir="$CONFIG_DIR"
    local workspace="$WORKSPACE"
    local container_name_prefix="${JOB_NAME}${JOB_ID}"

    if no_docker_publish "$workspace" "$DOCKER_PUBLISH"
    then
        header "running CI job (no Docker image)"
        run_ci_job "$container_name_prefix" "$workspace" "$config_dir" "$@"
    else
        if not_docker_published "$namespace" "$repo" "$short_tag" \
            || test "$DOCKER_PUBLISH_FORCE" != false
        then
            header "running CI job"
            run_ci_job "$container_name_prefix" "$workspace" "$config_dir" "$@"
            header "building Docker image"
            local image_hash
            image_hash="$(
                docker_build "$namespace" "$repo" "$short_tag" "$workspace")"
            header "publishing Docker image"
            docker_publish "$namespace" "$repo" "$short_tag" "$concern"
            docker rmi --force "$image_hash"
        else
            header "already published to Docker: $short_tag"
        fi
        write_report "$namespace" "$repo" "$short_tag" "$workspace"
    fi

    header "SUCCESS: finished everything"

}


source_conf()
{
    if [ -r "$USER_CONF" ]
    then . "$USER_CONF"
    fi
}


validate_inputs()
{
    set +u
    if [ -z "$JOB_NAME" ]
    then die "MISSING: required job name (-n switch)"
    fi
    set -u
}


make_concern()
{
    local concern="$1"
    if [ -n "$concern" ]
    then echo "$concern"
    else
        if on_ci_server
        then echo "dev"
        else whoami
        fi
    fi
}


make_short_tag()
{
    local workspace="$1"
    local concern="$2"
    local version
    version="$(version_from_git "$workspace")"
    if on_ci_server
    then echo "$version"
    else echo "$version-$concern"
    fi
}


no_docker_publish()
{
    local workspace="$1"
    local do_publish="$2"
    ! test -r "$workspace/Dockerfile" -a "$do_publish" != false
}


not_docker_published()
{
    local namespace="$1"
    local repo="$2"
    local version_tag="$3"
    local auth
    local token
    auth="$(docker_auth)"
    token="$(docker_token "$auth" "$namespace" "$repo")"
    curl -s -f -L \
            -H "Authorization: Bearer $token" \
            "$DOCKER_REGISTRY_URL/$namespace/$repo/tags/list" \
        | jq -e ".tags | map(in({\"$version_tag\": true})) | any | not"
}


run_ci_job()
{
    local container_name_prefix="$1"
    local workspace_dir="$2"
    local config_dir="$3"
    shift 3
    local compose_conf_common="$config_dir/c12e-ci.compose.common.yml"
    local compose_conf_specific
    compose_conf_specific="$config_dir/$(pick_compose_specific)"
    local compose_conf_build="$workspace_dir/c12e-ci.yml"
    compose_conf_build="$(pick_compose_build "$workspace_dir" "$config_dir")"

    set_cleanup \
        "$workspace_dir" \
        "$container_name_prefix" \
        "$compose_conf_common" \
        "$compose_conf_specific" \
        "$compose_conf_build"

    create_nix_data
    create_dev_home

    local C12ECI_CONTAINER; C12ECI_CONTAINER="$(container_id)"
    export C12ECI_CONTAINER
    local C12ECI_WORK_DIR
    export C12ECI_WORK_DIR="$workspace_dir"

    docker-compose \
        --project-name "$container_name_prefix" \
        --file "$compose_conf_common" \
        --file "$compose_conf_specific" \
        --file "$compose_conf_build" \
        run --rm builder \
        "$@"

}


docker_build()
{
    local namespace="$1"
    local repo="$2"
    local short_tag="$3"
    local workspace="$4"
    docker build \
            --pull=true \
            --force-rm=false \
            --tag "$namespace/$repo:$short_tag" \
            "$workspace" \
        | tee /dev/stderr \
        | tail -1 \
        | awk '{ print $3 }'
}


docker_publish()
{
    local namespace="$1"
    local repo="$2"
    local short_tag="$3"
    local concern="$4"
    local full_tag="$namespace/$repo:$short_tag"
    header "pushing Docker image: $full_tag"
    docker push "$full_tag"
    header "tagging Docker images"
    tag_all "$namespace" "$repo" "$short_tag" "$concern"
}


write_report()
{
    local namespace="$1"
    local repo="$2"
    local short_tag="$3"
    local workspace="$4"
    local target_dir="$workspace/cruise-output"
    local gitHash; gitHash="$(git rev-parse HEAD)"
    local timestamp; timestamp="$(date -u +%FT%TZ)"
    if on_ci_server
    then
        mkdir -p "$target_dir"
        cat << EOF > "$target_dir/buildReport.json"
{
   "name": "$repo",
   "docker_tag": "$namespace/$repo:$short_tag",
   "git_hash": "$gitHash",
   "timestamp": "$timestamp"
}
EOF
    fi
}


version_from_git()
{
    local workspace="$1"
    git -C "$workspace" describe --long --always --dirty --match='v*.*' \
        | sed 's/v//; s/-/./'
}


on_ci_server()
{
    test "$(whoami)" = "root"
}


docker_auth()
{
    jq \
            '.auths as $auth
                | $auth
                | keys
                | map(select(contains(".docker.")))[0] as $key
                | $auth
                | .[$key].auth' \
            "$HOME/.docker/config.json" \
        | xargs echo
}


docker_token()
{
    local auth="$1"
    local namespace="$2"
    local repo="$3"
    local headers="Authorization: Basic $auth"
    local actions="pull"
    curl -s -f -H "$headers" "$DOCKER_AUTH_URL:$namespace/$repo:$actions" \
        | jq '.token' \
        | xargs echo
}


pick_compose_specific()
{
    if on_ci_server
    then echo "c12e-ci.compose.gocd.yml"
    else echo "c12e-ci.compose.dev.yml"
    fi
}


pick_compose_build()
{
    local workspace="$1"
    local config_dir="$2"
    local workspace_config="$workspace/c12e-ci.yml"
    if [ -r "$workspace_config" ]
    then echo "$workspace_config"
    else echo "$config_dir/c12e-ci.compose.noop.yml"
    fi
}


create_nix_data()
{
    local name="nix-data"
    if ! container_created "$name"
    then
        docker run \
            --name "$name" \
            --entrypoint true \
            "$NIX_BUILDER_IMAGE"
    fi
}


create_dev_home()
{
    local name="dev-home"
    if ! (on_ci_server || container_created "$name")
    then
        mkdir -p "$HOME/.sbt" "$HOME/.ivy2" "$HOME/.docker"
        docker run \
            --name "$name" \
            --entrypoint /bin/cp \
            --volume "${HOME}:/mnt" \
            --volume /root \
            busybox \
            -r /mnt/.sbt /mnt/.ivy2 /mnt/.docker /root
    fi
}


container_id()
{
    if [ -r /proc/self/cgroup ]
    then $(basename "$(egrep '.*\bcpu\b.*:/docker/' /proc/self/cgroup)")
    fi
}


tag_all()
{
    local namespace="$1"
    local repo="$2"
    local original="$3"
    local concern="$4"
    for new in "${concern}-latest" "latest-${concern}"
    do tag_one "$namespace" "$repo" "$original" "$new"
    done
    if on_ci_server
    then tag_one "$namespace" "$repo" "$original" "${original}-${concern}"
    fi
}


tag_one()
{
    local namespace="$1"
    local repo="$2"
    local original="$3"
    local new="$4"
    local image_name="$namespace/$repo"
    echo "tagging $image_name: $new -> $original"
	docker tag "$image_name:$original" "$image_name:$new"
	docker push "$image_name:$new"
}


container_created()
{
    local name="$1"
    docker ps --all --format "{{.Names}}" | grep "^${name}$"
}


set_cleanup()
{
    local workspace_dir="$1"
    local container_name_prefix="$2"
    local compose_conf_common="$3"
    local compose_conf_specific="$4"
    local compose_conf_build="$5"
    # DESIGN: http://mywiki.wooledge.org/SignalTrap
    local cmd="cleanup \
            $workspace_dir \
            $container_name_prefix \
            $compose_conf_common \
            $compose_conf_specific \
            $compose_conf_build"
    trap "$cmd" EXIT
    trap "$cmd; trap - INT; kill -INT $$; sleep 1" INT TERM
}


cleanup()
{
    local workspace_dir="$1"
    local container_name_prefix="$2"
    local compose_conf_common="$3"
    local compose_conf_specific="$4"
    local compose_conf_build="$5"

    header "cleaning up Docker processes"

    local C12ECI_CONTAINER; C12ECI_CONTAINER="$(container_id)"
    export C12ECI_CONTAINER
    local C12ECI_WORK_DIR
    export C12ECI_WORK_DIR="$workspace_dir"

    docker-compose \
        --project-name "$container_name_prefix" \
        --file "$compose_conf_common" \
        --file "$compose_conf_specific" \
        --file "$compose_conf_build" \
        stop

    docker-compose \
        --project-name "$container_name_prefix" \
        --file "$compose_conf_common" \
        --file "$compose_conf_specific" \
        --file "$compose_conf_build" \
        rm --force -v

    header "cleaning up dangling Docker images"

    for image in $(docker images --filter "dangling=true" --quiet --no-trunc)
    do docker rmi --force "$image" || true
    done

    header "cleaning up workspace"

    local ownership
    ownership="$(id -u):$(id -g)"

    docker run \
        --name "${container_name_prefix}_clean_workspace" \
        --rm \
        --volume "${workspace_dir}:/workspace" \
        busybox:latest \
        chown -R "$ownership" /workspace || true

    header "finished cleanup"
}


canonical()
{
    echo "$@" | sed 's/[^a-zA-Z0-9_-]//g' | tr '[:upper:]' '[:lower:]'
}


header()
{
    echo
    echo "****"
    echo "**** $*"
    echo "****"
    echo
}


abspath()
{
    local target="$1"
    local old_pwd
    old_pwd="$(pwd)"
    cd "$(dirname "$target")"
    while [ -L "$target" ]; do
        target="$(readlink "$target")"
        cd "$(dirname "$target")"
    done
    echo "$(pwd -P)/$(basename "$target")"
    cd "$old_pwd"
}


die()
{
    local msg="$1"
    {
        echo "$USAGE"
        echo
        echo "ERROR: $msg"
    } > /dev/stderr
    exit 1
}


main "$@"
