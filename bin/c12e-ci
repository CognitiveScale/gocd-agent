#!/bin/bash -eu

ORIG_PROG_BIN="$0"
DOCKER_AUTH_URL="https://auth.docker.io/token?service=registry.docker.io&scope=repository"
DOCKER_REGISTRY_URL="https://registry-1.docker.io/v2"
NIX_BUILDER_IMAGE="c12e/c12e-nix-builder:0.0.6-g83f2ce9"
DOCKERFILE="Dockerfile"

set_globals()
{
    PROG_BIN="$(abspath "$ORIG_PROG_BIN")"
    PROG_DIR="$(dirname "$PROG_BIN")"
    PROG_NAME="$(basename "$PROG_BIN")"
    USER_CONF="$HOME/.$PROG_NAME"
    CONFIG_DIR="$(abspath "$PROG_DIR/../etc")"
    CONCERN=""
    JOB_ID="$$"
    DOCKER_PUBLISH="false"
    DOCKER_PUBLISH_FORCE="false"
    DOCKER_PUBLISH_LOCAL="false"
    IMAGE_NAMESPACE="c12e"
    WORKSPACE="$(pwd)"
    DEBUG_LEVEL="0"  # IDEA: actually use DEBUG_LEVEL
    USAGE="$PROG_NAME [options...] [COMMAND ARGS...]

Run continuous integration job.

A c12e-ci.yml file is normally in the workspace to define how to run the job
with Docker-compose.  Otherwise, the command is a no-op.  You can override the
command optionally from the command-line.

You can set these options in $USER_CONF using the argument names
documented here.

Options:

    -c CONCERN
        a tag for the job and Docker image (dev, qa, ...)

    -p
        build and publish Docker images (just run CI job)
        (default: $DOCKER_PUBLISH)
    -l
        build locally, but don't push (overrides -p and -F)
        (default: $DOCKER_PUBLISH_LOCAL)

    -I JOB_ID
        unique identification for each job run (like CI build number,
        default is the PID)

    -w WORKSPACE
        when building, the volume to mount as a the build source code root
        (default: current working directory)

    -N IMAGE_NAMESPACE
        the Docker namespace to use when building and publishing the artifact
        (default: $IMAGE_NAMESPACE)

    -F
        ignore the existing tag in docker and republish
        (default: $DOCKER_PUBLISH_FORCE)

    -h
        print this usage information"
}


main()
{
    set_globals
    source_conf
    while getopts c:I:w:N:pFlvh f
    do
        case $f in
            c) CONCERN="$(canonical "${OPTARG}")";;
            I) JOB_ID="$(canonical "${OPTARG}")";;
            w) WORKSPACE="$(abspath "$OPTARG")";;
            N) IMAGE_NAMESPACE="$(canonical "$OPTARG")";;
            p) DOCKER_PUBLISH="true";;
            F) DOCKER_PUBLISH_FORCE="true";;
            l) DOCKER_PUBLISH_LOCAL="true"
               DOCKER_PUBLISH="true"
               DOCKER_PUBLISH_FORCE="true";;
            v) DEBUG_LEVEL="$((DEBUG_LEVEL + 1))";;
            h) echo "$USAGE"; exit 0;;
            \?) die "missing required argument to switch";;
        esac
    done
    shift $((OPTIND - 1))

    validate_inputs

    local concern
    concern="$(make_concern "$CONCERN")"

    local short_tag
    short_tag="$(make_short_tag "$WORKSPACE" "$concern" "$DOCKER_PUBLISH_LOCAL")"

    local namespace="$IMAGE_NAMESPACE"
    local config_dir="$CONFIG_DIR"
    local workspace="$WORKSPACE"
    local container_name_prefix="${JOB_ID}"

    local required_work
    required_work="$(
        detect_required_work \
            "$DOCKER_PUBLISH" \
            "$DOCKER_PUBLISH_FORCE" \
            "$namespace" \
            "$short_tag" \
            "$workspace")"

    local do_ci_run
    do_ci_run="$(echo "$required_work" | head -1)"

    local to_publish
    to_publish="$(echo "$required_work" | tail -n +2)"

    if [ "$do_ci_run" = true ]
    then
        header "running CI job"
        run_ci_job "$container_name_prefix" "$workspace" "$config_dir" "$@"
    else
        header "nothing new to publish"
    fi

    echo "$to_publish" | \
        while read -r pair
        do
            local repo
            local dockerfile
            repo="$(echo "$pair" | { IFS=: read -r fst snd; echo "$fst"; })"
            dockerfile="$(
                echo "$pair" | { IFS=: read -r fst snd; echo "$snd"; })"
            if test -z "$repo" || test -z "$dockerfile"
            then continue
            fi
            header "building Docker image"
            local build_path
            build_path="$(dirname "$dockerfile")"
            local image_hash
            image_hash="$(
                docker_build \
                    "$namespace" \
                    "$repo" \
                    "$short_tag" \
                    "$dockerfile" \
                    "$build_path")"
            if [ "$DOCKER_PUBLISH_LOCAL" = false ]
            then
                header "publishing Docker image"
                docker_publish "$namespace" "$repo" "$short_tag" "$concern"
                docker rmi --force "$image_hash"
            fi
        done

    write_report "$namespace" "$short_tag" "$workspace" "$to_publish"
    header "SUCCESS: finished everything"

}


source_conf()
{
    if [ -r "$USER_CONF" ]
    then . "$USER_CONF"
    fi
}


validate_inputs()
{
    set +u
    set -u
}


make_concern()
{
    local concern="$1"
    if [ -n "$concern" ]
    then echo "$concern"
    else
        if on_ci_server
        then echo "dev"
        else whoami
        fi
    fi
}


make_short_tag()
{
    local workspace="$1"
    local concern="$2"
    local publish_local="$3"
    local version
    version="$(version_from_git "$workspace")"
    if on_ci_server || test "$publish_local" = "true"
    then echo "$version"
    else echo "$version-$concern"
    fi
}


detect_required_work()
{
    local do_docker_publish="$1"
    local force_docker_publish="$2"
    local namespace="$3"
    local short_tag="$4"
    local workspace="$5"
    local do_ci_run="false"
    local to_publish=""
    if no_docker_publish "$workspace" "$do_docker_publish"
    then
        do_ci_run="true"
    else
        to_publish="$(
            find "$workspace/" -name 'Dockerfile.c12e-ci.*' -type f | {
                while read -r f
                do
                    local repo
                    repo="$(basename "$f")"
                    repo="${repo#Dockerfile.c12e-ci.}"
                    repo="$(canonical "$repo")"
                    if not_docker_published "$namespace" "$repo" "$short_tag" \
                        || test "$force_docker_publish" != false
                    then echo "${repo}:${f}"
                    fi
                done
            })"
    fi
    if [ -n "$to_publish" ]
    then do_ci_run="true"
    fi
    echo "$do_ci_run"
    echo "$to_publish"
}


no_docker_publish()
{
    local workspace="$1"
    local do_publish="$2"
    local files
    files="$(find "$workspace" -name "$DOCKERFILE" -type f)"
    test -z "$files" || test "$do_publish" = false
}


not_docker_published()
{
    local namespace="$1"
    local repo="$2"
    local version_tag="$3"
    local auth
    local token
    auth="$(docker_auth)"
    token="$(docker_token "$auth" "$namespace" "$repo")"
    local jq_script=".tags | map(in({\"$version_tag\": true})) | any | not"
    curl -s -f -L \
            -H "Authorization: Bearer $token" \
            "$DOCKER_REGISTRY_URL/$namespace/$repo/tags/list" \
        | jq -e "$jq_script" > /dev/null
}


run_ci_job()
{
    local container_name_prefix="$1"
    local workspace_dir="$2"
    local config_dir="$3"
    shift 3
    local compose_conf_common="$config_dir/c12e-ci.compose.common.yml"
    local compose_conf_specific
    compose_conf_specific="$config_dir/$(pick_compose_specific)"
    local compose_conf_build="$workspace_dir/c12e-ci.yml"
    compose_conf_build="$(pick_compose_build "$workspace_dir" "$config_dir")"

    set_cleanup \
        "$workspace_dir" \
        "$container_name_prefix" \
        "$compose_conf_common" \
        "$compose_conf_specific" \
        "$compose_conf_build"

    create_nix_data
    create_dev_home

    local C12ECI_CONTAINER; C12ECI_CONTAINER="$(container_id)"
    export C12ECI_CONTAINER
    local C12ECI_WORK_DIR
    export C12ECI_WORK_DIR="$workspace_dir"

    docker-compose \
        --project-name "$container_name_prefix" \
        --file "$compose_conf_common" \
        --file "$compose_conf_specific" \
        --file "$compose_conf_build" \
        run --rm builder \
        "$@"

}


docker_build()
{
    local namespace="$1"
    local repo="$2"
    local short_tag="$3"
    local dockerfile="$4"
    local build_path="$5"
    docker build \
            --file="$dockerfile" \
            --pull=true \
            --force-rm=false \
            --tag "$namespace/$repo:$short_tag" \
            "$build_path" \
        | tee /dev/stderr \
        | tail -1 \
        | awk '{ print $3 }'
}


docker_publish()
{
    local namespace="$1"
    local repo="$2"
    local short_tag="$3"
    local concern="$4"
    local full_tag="$namespace/$repo:$short_tag"
    header "pushing Docker image: $full_tag"
    docker push "$full_tag"
    header "tagging Docker images"
    tag_all "$namespace" "$repo" "$short_tag" "$concern"
}


write_report()
{
    local namespace="$1"
    local short_tag="$2"
    local workspace="$3"
    local published="$4"
    local target_dir="$workspace/cruise-output"
    local gitHash; gitHash="$(git rev-parse HEAD)"
    local timestamp; timestamp="$(date -u +%FT%TZ)"
    local printed_first="false"
    if on_ci_server
    then
        mkdir -p "$target_dir"
        echo "[" >> "$target_dir/buildReport.json"
        echo "$published" | \
            while read -r pair
            do
                local repo
                local dockerfile
                repo="$(
                    echo "$pair" | { IFS=: read -r fst snd; echo "$fst"; })"
                dockerfile="$(
                    echo "$pair" | { IFS=: read -r fst snd; echo "$snd"; })"
                if test -z "$repo" || test -z "$dockerfile"
                then continue
                fi
                if [ "$printed_first" = "true" ]
                then echo "," >> "$target_dir/buildReport.json"
                fi
                cat << EOF > "$target_dir/buildReport.json"
{
   "name": "$repo",
   "docker_file": "$dockerfile",
   "docker_tag": "$namespace/$repo:$short_tag",
   "git_hash": "$gitHash",
   "timestamp": "$timestamp"
}
EOF
                printed_first="true"
            done
        echo "]" >> "$target_dir/buildReport.json"
    fi
}


version_from_git()
{
    local workspace="$1"
    git -C "$workspace" describe --long --always --dirty --match='v*.*' \
        | sed 's/v//; s/-/./'
}


on_ci_server()
{
    test "$(whoami)" = "root"
}


docker_auth()
{
    jq \
            '.auths as $auth
                | $auth
                | keys
                | map(select(contains(".docker.")))[0] as $key
                | $auth
                | .[$key].auth' \
            "$HOME/.docker/config.json" \
        | xargs echo
}


docker_token()
{
    local auth="$1"
    local namespace="$2"
    local repo="$3"
    local headers="Authorization: Basic $auth"
    local actions="pull"
    curl -s -f -H "$headers" "$DOCKER_AUTH_URL:$namespace/$repo:$actions" \
        | jq '.token' \
        | xargs echo
}


pick_compose_specific()
{
    if on_ci_server
    then echo "c12e-ci.compose.gocd.yml"
    else echo "c12e-ci.compose.dev.yml"
    fi
}


pick_compose_build()
{
    local workspace="$1"
    local config_dir="$2"
    local workspace_config="$workspace/c12e-ci.yml"
    if [ -r "$workspace_config" ]
    then echo "$workspace_config"
    else echo "$config_dir/c12e-ci.compose.noop.yml"
    fi
}


create_nix_data()
{
    local name="nix-data"
    if ! container_created "$name"
    then
        docker run \
            --name "$name" \
            --entrypoint true \
            "$NIX_BUILDER_IMAGE"
    fi
}


create_dev_home()
{
    local name="dev-home"
    if ! (on_ci_server || container_created "$name")
    then
        mkdir -p "$HOME/.sbt" "$HOME/.ivy2" "$HOME/.docker" "$HOME/.nixpkgs"
        docker run \
            --name "$name" \
            --volume /root \
            busybox
        docker run \
            --name "$name-cp" \
            --rm \
            --entrypoint /bin/cp \
            --volume "${HOME}:/mnt" \
            --volumes-from "$name" \
            busybox \
            -r /mnt/.sbt /mnt/.ivy2 /mnt/.docker /mnt/.nixpkgs /root
    fi
}


container_id()
{
    if [ -r /proc/self/cgroup ]
    then basename "$(egrep '.*\bcpu\b.*:/docker/' /proc/self/cgroup)"
    fi
}


tag_all()
{
    local namespace="$1"
    local repo="$2"
    local original="$3"
    local concern="$4"
    for new in "${concern}-latest" "latest-${concern}"
    do tag_one "$namespace" "$repo" "$original" "$new"
    done
    if on_ci_server
    then tag_one "$namespace" "$repo" "$original" "${original}-${concern}"
    fi
}


tag_one()
{
    local namespace="$1"
    local repo="$2"
    local original="$3"
    local new="$4"
    local image_name="$namespace/$repo"
    echo "tagging $image_name: $new -> $original"
    docker tag "$image_name:$original" "$image_name:$new"
    docker push "$image_name:$new"
}


container_created()
{
    local name="$1"
    docker ps --all --format "{{.Names}}" | grep "^${name}$"
}


set_cleanup()
{
    local workspace_dir="$1"
    local container_name_prefix="$2"
    local compose_conf_common="$3"
    local compose_conf_specific="$4"
    local compose_conf_build="$5"
    # DESIGN: http://mywiki.wooledge.org/SignalTrap
    local cmd="cleanup \
            $workspace_dir \
            $container_name_prefix \
            $compose_conf_common \
            $compose_conf_specific \
            $compose_conf_build"
    trap "$cmd" EXIT
    trap "$cmd; trap - INT; kill -INT $$; sleep 1" INT TERM
}


cleanup()
{
    local workspace_dir="$1"
    local container_name_prefix="$2"
    local compose_conf_common="$3"
    local compose_conf_specific="$4"
    local compose_conf_build="$5"

    header "cleaning up Docker processes"

    local C12ECI_CONTAINER; C12ECI_CONTAINER="$(container_id)"
    export C12ECI_CONTAINER
    local C12ECI_WORK_DIR
    export C12ECI_WORK_DIR="$workspace_dir"

    header "Stopping build stack"
    docker-compose \
        --project-name "$container_name_prefix" \
        --file "$compose_conf_common" \
        --file "$compose_conf_specific" \
        --file "$compose_conf_build" \
        stop

    header "Removing build stack"
    docker-compose \
        --project-name "$container_name_prefix" \
        --file "$compose_conf_common" \
        --file "$compose_conf_specific" \
        --file "$compose_conf_build" \
        rm --force -v

    header "cleaning up dangling Docker images"

    docker images --filter "dangling=true" --quiet --no-trunc \
        | grep -v nix-data \
        | \
            while read -r image
            do docker rmi --force "$image" || true
            done

    header "cleaning up dangling Docker volumes"

    docker volume ls -q -f dangling=true \
        | grep -v volume \
        | \
            while read -r volume
            do docker volume rm "$volume" || true
            done

    header "cleaning up workspace"

    local ownership
    ownership="$(id -u):$(id -g)"

    docker run \
        --name "${container_name_prefix}_clean_workspace" \
        --rm \
        --volume "${workspace_dir}:/workspace" \
        busybox:latest \
        chown -R "$ownership" /workspace || true

    header "finished cleanup"
}


canonical()
{
    echo "$@" | sed 's/[^a-zA-Z0-9_-]//g' | tr '[:upper:]' '[:lower:]'
}


header()
{
    echo
    echo "****"
    echo "**** $*"
    echo "****"
    echo
}


abspath()
{
    local target="$1"
    local old_pwd
    old_pwd="$(pwd)"
    cd "$(dirname "$target")"
    while [ -L "$target" ]; do
        target="$(readlink "$target")"
        cd "$(dirname "$target")"
    done
    echo "$(pwd -P)/$(basename "$target")"
    cd "$old_pwd"
}


die()
{
    local msg="$1"
    {
        echo "$USAGE"
        echo
        echo "ERROR: $msg"
    } > /dev/stderr
    exit 1
}


main "$@"
