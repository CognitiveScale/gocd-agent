#!/bin/bash -ux
ORIG_PROG_BIN="$0"
set_globals()
{
    PROG_BIN="$(abspath "$ORIG_PROG_BIN")"
    PROG_NAME="$(basename "$PROG_BIN")"
    USER_CONF="$HOME/.$PROG_NAME"
    CONCERN=""
    SERVICE_IMAGES=""
    JOB_ID="$$"
    DO_PUBLISH="false"
    DOCKER_TAG_ENFORCE="false"
    IMAGE_NAMESPACE="c12e"
    IMAGE_NAMESPACE_DEFAULT="c12e"
# Rancher mangles the name ... grrrr...
    CONTAINER=${HOSTNAME}
    VOLUME_BUILD_HOME_RW=$(docker inspect "${CONTAINER}" | jq -r '.[0].Mounts[] | select(.Destination | contains("/root")) | .Name')
    VOLUME_BUILD_WORKSPACE_VOLUME=$(docker inspect "${CONTAINER}" | jq -r '.[0].Mounts[] | select(.Destination | contains("/work")) | .Name')
    VOLUME_BUILD_WORKSPACE="$(pwd)"
    VOLUME_SERVICE_TMP="/tmp"
    DEBUG_LEVEL="0"  # IDEA: actually use DEBUG_LEVEL
    DOCKERFILE=docker-compose.yml
    USAGE="$PROG_NAME -n JOB_NAME -i JOB_IMAGE_BASE [options]...
    COMMAND ARGS...

Run continuous integration jobs.

You can set these options in $USER_CONF using
the argument names documented here.

Required:

    -n JOB_NAME
        insights, dss, retailsearch, ...
        (used for Docker image/container names)

    -i JOB_IMAGE_BASE
        Docker image to use when building workspace

Options:

    -c CONCERN
        $CONCERN (default), dev, qa, ...

    -s SERVICE_IMAGES
        Docker dependencies for compiling/testing (like c12e/neo4j:2.2.0);
        the default namespace is \"c12e\"

    -p
        Build and publish Docker images (just run CI job)

    -I JOB_ID
        unique identification for each job run (like CI build number,
        default is the PID)

    -W VOLUME_BUILD_HOME_RW
        when building, the volume to mount as root/ for caching
        (default: $VOLUME_BUILD_HOME_RW)

    -t VOLUME_SERVICE_TMP
        volume to mount for temporary data of build dependency containers
        (default: $VOLUME_SERVICE_TMP)

    -w VOLUME_BUILD_WORKSPACE
        when building, the volume to mount as a the build source code root
        (default: current working directory)

    -N IMAGE_NAMESPACE
        the Docker namespace to use when building and publishing the artifact
        (default: $IMAGE_NAMESPACE)

    -t DOCKER_TAG_ENFORCE
        ignore the existing tag in docker and republish
        (default: false)
    -h
        print this usage information"
}


main()
{
    set_globals
    source_conf
    while getopts n:i:c:s:I:W:t:w:N:pvh f
    do
        case $f in
            n) JOB_NAME="$(canonical "${OPTARG}")";;
            i) JOB_IMAGE_BASE=${OPTARG};;
            c) CONCERN="$(canonical "${OPTARG}")";;
            s) SERVICE_IMAGES="${SERVICE_IMAGES} ${OPTARG}";;
            I) JOB_ID="$(canonical "${OPTARG}")";;
            W) VOLUME_BUILD_HOME_RW="$(abspath "$OPTARG")";;
            t) VOLUME_SERVICE_TMP="$(abspath "$OPTARG")";;
            w) VOLUME_BUILD_WORKSPACE="$(abspath "$OPTARG")";;
            N) IMAGE_NAMESPACE="$(canonical "$OPTARG")";;
            p) DO_PUBLISH="true";;
            t) DOCKER_TAG_ENFORCE="true";;
            v) DEBUG_LEVEL="$((DEBUG_LEVEL + 1))";;
            h) echo "$USAGE"; exit 0;;
            \?) die "missing required argument to switch";;
        esac
    done
    shift $((OPTIND - 1))

    validate_inputs
    local version
    version="$(version_from_git "$VOLUME_BUILD_WORKSPACE")"
    local service_dir
    service_dir="$VOLUME_SERVICE_TMP/$JOB_NAME-$JOB_ID"
    local container_name_prefix
    container_name_prefix="${JOB_NAME}_${CONCERN}_${JOB_ID}"
    local short_tag
    short_tag="$(make_short_tag "$version" "$CONCERN")"
    local full_tag
    full_tag="$(make_full_tag "$IMAGE_NAMESPACE" "$JOB_NAME" "$short_tag")"
    local tag_url_base
    tag_url_base="$(make_tag_url_base "$IMAGE_NAMESPACE" "$JOB_NAME")"

    if no_docker_publish "$VOLUME_BUILD_WORKSPACE" "$DO_PUBLISH"
    then
        header "running CI job (no Docker image)"
        run_ci_job_with_services \
            "$service_dir" \
            "$container_name_prefix" \
            "$SERVICE_IMAGES" \
            "$VOLUME_BUILD_WORKSPACE" \
            "$VOLUME_BUILD_HOME_RW" \
            "$JOB_IMAGE_BASE" \
            "$@"
    else
        if [ ! $DOCKER_TAG_ENFORCE = "true" ] || not_docker_published "$tag_url_base" "$short_tag"
        then
            header "running CI job"
            run_ci_job_with_services \
                "$service_dir" \
                "$container_name_prefix" \
                "$SERVICE_IMAGES" \
                "$VOLUME_BUILD_WORKSPACE" \
                "$VOLUME_BUILD_HOME_RW" \
                "$JOB_IMAGE_BASE" \
                "$@"
            header "building Docker image"
            image_hash=$(docker_build "$full_tag" "$VOLUME_BUILD_WORKSPACE")
            header "publishing Docker image"
            docker_publish "$full_tag" "$short_tag" "$image_hash" "$CONCERN"
        else
            header "already published to Docker: $short_tag"
        fi
    fi
    header "SUCCESS: finished everything"
}


source_conf()
{
    if [ -r "$USER_CONF" ];then
# shellcheck source=/dev/null
      source "$USER_CONF"
    fi
}


validate_inputs()
{
    set +u
    if [ -z "$JOB_NAME" ]
    then die "MISSING: required job name (-n switch)"
    elif [ -z "$JOB_IMAGE_BASE" ]
    then die "MISSING: job image base (-i switch)"
    fi
    set -u
}


version_from_git()
{
    local workspace="$1"
    git -C "$workspace" describe --long --always --match='v*.*' \
        | sed 's/v//; s/-/./'
}


make_short_tag()
{
  local version="$1"
  local concern="$2"
  if dev_mode "$concern"
  then echo "$version-$(make_concern "$concern")"
  else echo "$version"
  fi
}


make_full_tag()
{
  local image_namespace="$1"
  local job_name="$2"
  local tag="$3"
  echo "$image_namespace/$job_name:$tag"
}


make_concern()
{
  local concern="$1"
  if dev_mode "$concern"
  then whoami
  else echo "$concern"
  fi
}


dev_mode()
{
  local concern="$1"
  if [ -n "$concern" ]
  then return 1
  else return 0
  fi
}


make_tag_url_base()
{
    local namespace="$1"
    local job="$2"
    echo "https://registry.hub.docker.com/v1/repositories/$namespace/$job/tags"
}


no_docker_publish()
{
    local workspace="$1"
    local do_publish="$2"
    ! test -r "$workspace/Dockerfile" -a "$do_publish" = true
}

run_ci_job_with_services()
{
    local service_dir="$1"
    local container_name_prefix="$2"
    local service_images="$3"
    local volume_build_workspace="$4"
    local volume_build_home_rw="$5"
    local job_image_base="$6"
    shift 6
    set_cleanup "$service_dir" "$volume_build_workspace" "$container_name_prefix"
    mv ${DOCKERFILE} ${DOCKERFILE}.prev
    raw_service_data="$(start_services "$container_name_prefix" "$service_images")"
    envstring=$(grep -v "^LNK" <<< "$raw_service_data")
    link_tmp=$(grep "^LNK" <<< "$raw_service_data" | sed -E 's/^.{3}//')
    links=""
    [ ! -z "$link_tmp" ] && links=$(cat<<EOF
  links:
$link_tmp
EOF
)
    run_ci_job \
        "$service_dir" \
        "$container_name_prefix" \
        "$volume_build_workspace" \
        "$volume_build_home_rw" \
        "$envstring" \
        "$links" \
        "$job_image_base" \
        "$@"
}


not_docker_published()
{
    return 0
    local tag_url_base="$1"
    local version_tag="$2"
    url="$tag_url_base/$version_tag"
    local status
    status="$(
        curl --basic --netrc --silent --include "$url" | head -n 1 | awk '{print $2}')"
    if [ "$status" -eq 200 ]; then
      return 1
    elif [ "$status" -eq 404 ]; then
      return 0
    else
       die "$url returned error: $status"
    fi
}


docker_build()
{
    local tag="$1"
    local workspace="$2"
    docker build --pull=true --force-rm=false --tag "$tag" "$workspace" | tee /dev/stderr | tail -1 | awk '{ print $3 }'
}


docker_publish()
{
    local full_tag="$1"
    local short_tag="$2"
    local image_hash="$3"
    local concern="$4"
    docker push "$full_tag"
    header "tagging Docker images"
    tag "$IMAGE_NAMESPACE/$JOB_NAME" "$short_tag" "$concern"
    docker rmi -f "$image_hash"
}


tag()
{
    local image_name="$1"
    local original="$2"
    local concern="$3"
    local targets
    targets="$(make_concern "$concern")-latest latest-$(make_concern "$concern")"
    if ! dev_mode "$concern"; then
       targets="$targets $original-$concern"
    fi
    for new in $targets
    do
        echo "tagging: $new -> $original"
# tag force..
	docker tag -f "$image_name:$original" "$image_name:$new"
	docker push "$image_name:$new"
    done
}


set_cleanup()
{
    local service_dir="$1"
    local workspace_dir="$2"
    local container_name_prefix="$3"
    # DESIGN: http://mywiki.wooledge.org/SignalTrap
    trap "cleanup $service_dir $workspace_dir $container_name_prefix" EXIT
    trap "cleanup $service_dir $workspace_dir $container_name_prefix;
            trap - INT;
            kill -INT $$;
            sleep 1" \
        INT TERM
}


start_services()
{
    local container_name_prefix="$1"
    shift 1 
    [ ! -z $1 ] && for service_image in "$@"; do
        start_service "$container_name_prefix" "$service_image"
    done
}

start_service()
{
    local container_name_prefix="$1"
    local service_image
    service_image="$(expand_image_name "$2")"
    local image_repo_tag
    image_repo_tag="${service_image##*/}"
    local image_repo
    image_repo="${image_repo_tag%:*}"
# yuck will need to strip off first line to build links :(
    echo "LNK   - $image_repo:$image_repo"
    run_service "$image_repo" "$service_image"
    case "$image_repo" in
        redis)
            echo "    - REDIS_HOST=$image_repo"
            echo "    - REDIS_PORT=6379"
            ;;
        mongodb)
            echo "    - MONGO_HOST=$image_repo"
            echo "    - MONGO_PORT=27017"
            ;;
        neo4j)
            echo "    - NEO4J_HOST=$image_repo"
            echo "    - NEO4J_PORT=7474"
            ;;
    esac
}

wait_until()
{
    local count=1
    while ! "$@"; do
        sleep 1
        count="$((count + 1))"
        if [ $count -gt 600 ]; then
           die "timed out waiting for service: $*"
        fi
    done
}


mongo_up()
{
    local log_dir="$1"
# 2.4.x and 3.x messages are different
    grep -q 'replSet PRIMARY\|primary complete' "${log_dir}/mongodb.log" 2> /dev/null
}


run_service()
{
    local image_repo="$1"
    local service_image="$2"
cat >> $DOCKERFILE <<EOF
${image_repo}:
   image: ${service_image}

EOF
}


run_ci_job()
{
    local service_dir="$1"
    local container_name_prefix="$2"
    local workspace_dir="$3"
    local home_rw="$4"
    local env_vars="$5"
    local link_switches="$6"
    local build_image_base="$7"
    shift 7
cat >> $DOCKERFILE <<EOF
${container_name_prefix}_builder:
  image: $build_image_base
  volumes:
    - ${home_rw}:/root
    - ${VOLUME_BUILD_WORKSPACE_VOLUME}:/work
  working_dir: ${workspace_dir}
  user: root
  command: "$@"
  environment:
    - HOME=/root
    - USER=root
$env_vars
$link_switches

EOF

#docker-compose -f $DOCKERFILE up -d
# attach to the build job
#docker attach "${container_name_prefix}_builder"
}

cleanup()
{
     local service_dir="$1"
     local workspace_dir="$2"
     local container_name_prefix="$3"

     header "cleaning up Docker temporary files"

     rm -r -f "$service_dir"

     header "cleaning up Docker processes"

     docker-compose -f $DOCKERFILE stop
     docker-compose -f $DOCKERFILE rm -v

     header "cleaning up dangling Docker images"

     docker rmi "$(docker images --filter "dangling=true" --quiet --no-trunc)"

     header "cleaning up workspace"

     local ownership
     ownership="$(id -u):$(id -g)"

     docker run \
         --name "${container_name_prefix}_clean_workspace" \
         --rm \
         --volume "${workspace_dir}:/workspace" \
         busybox:latest \
         chown -R "$ownership" /workspace

    header "finished cleanup"
}


die()
{
    local msg="$1"
    {
        echo "$USAGE"
        echo
        echo "ERROR: $msg"
    } > /dev/stderr
    exit 1
}


canonical()
{
    echo "$@" | sed 's/[^a-zA-Z0-9]//g' | tr '[:upper:]' '[:lower:]'
}

expand_image_name()
{
    local short_name="$1"

    if is_in / "$short_name"
    then local namespace="${short_name%/*}"
    else local namespace="$IMAGE_NAMESPACE_DEFAULT"
    fi

    local image_repo_tag="${short_name##*/}"

    if is_in : "$image_repo_tag"
    then local tag="${image_repo_tag#*:}"
    else local tag="latest"
    fi

    local repo="${image_repo_tag%:*}"

    echo "$namespace/$repo:$tag"
}


is_in()
{
    substring="$1"
    string="$2"
    if test "${string#*$substring}" != "$string"; then
        return 0
    else
        return 1
    fi
}


header()
{
    echo
    echo "****"
    echo "**** $*"
    echo "****"
    echo
}


abspath()
{
    local target="$1"
    local old_pwd
    old_pwd="$(pwd)"
    cd "$(dirname "$target")"
    while [ -L "$target" ]; do
        target="$(readlink "$target")"
        cd "$(dirname "$target")"
    done
    echo "$(pwd -P)/$(basename "$target")"
    cd "$old_pwd"
}


is_mac()
{
    test "$(uname)" = "Darwin"
}


main "$@"
